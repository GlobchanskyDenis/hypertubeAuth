package controller

import (
	"HypertubeAuth/logger"
	"net/http"
)

func info(w http.ResponseWriter, r *http.Request) {
	response := `<html><header><title>Hypertube endpoint info</title></header><body>
	<h2><b>Endpoints:</b></h2>
	<b>GET /user/auth/basic</b> - базовая авторизация пользователя</br>
	<b>GET /user/auth/oauth42</b> - делегированная авторизация пользователя через api 42</br>
	<b>PUT /user/create/basic</b> - базовая регистрация пользователя пользователя</br>
	<b>POST /token/decode</b> - проверка, авторизирован ли пользователь. Для использования нужно знать пароль к серверу</br>
	<b>GET /info</b> - информация об энпоинтах, детали реализации</br>
	</br>

	<b>Обработка ошибок</b></br>
	В случае проваленного запроса сервер отвечает json в request body имеющим следующие поля:</br>
	description_ru - описание ошибки на русском. Можно показывать напрямую пользователю</br>
	description_eng - описание ошибки на английском. Можно показывать напрямую пользователю</br>
	code - код ошибки (тебе он врядли понадобится, это для моего тестирования)</br>
	Также сервер отвечает кодами, на которые тебе нужно реагировать:</br>
	400 BadRequest - в случае если ТЫ накосячил с запросом. Пользователь по идее не может привести к подобной ситуации</br>
	401 Unauthorized - сервер авторизации так ответить не может, но другие серверы так сообщают что нужно перебросить юзера на авторизацию</br>
	406 NotAcceptable - бизнес логика. Такое встречается если действие юзера невозможно из-за состояния БД (нет такого юзера и т.д)</br>
	422 UnprocessableEntity - в случае если юзер накосячил с аргументом запроса. Например мыло невалидное или пароль короткий</br>
	500 InternalServerError - может возникать в случае если например в конфигах неверная инфа (пороль БД, пароль почты...)</br>
	&emsp;&emsp;также возможны случаи, когда 500 возвращается в случае косяка в моем коде. Просьба сообщать мне о таких случаях</br>
	&emsp;&emsp;Отследить такое поведение просто - видишь 500 - смотришь что при этом напечатал в консоль мой логгер</br>
	&emsp;&emsp;и шлешь мне что ожидал, что получил и последние НЕСКОЛЬКО строк из логгера</br></br>

	<b>Базовая авторизация</b></br>
	Оформлена по стандарту RFC 2617, раздел 2. Идентификатор пользователя (его почта) и пароль передаются</br>
	одним заголовком, закодированным в base64. Схема:</br>
	Authorization: Basic base64( url_encoded_email <b>:</b> url_encoded_password ) </br>
	Если мыло = "Aladdin" а пароль = "open sesame", то финальный вид заголовка примет вид:</br>
	Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</br>
	В моем примере (папка client) есть рабочий вариант кода</br>
	Успешная авторизация - код 200 и json в request body содержащий одно поле - access_token. Токен бессрочный</br>
	Провал авторизации: описанная выше ошибка</br></br>

	<b>Базовая регистрация пользователя</b></br>
	Обязательные поля для заполнения: email, passwd</br>
	Необязательные поля: first_name, last_name, displayname, image_body</br>
	Я не делаю эндпоинта для апдейта всех полей юзера, поэтому лучше пусть юзер их всех укажет при регистрации</br>
	Успешная регистрация - код 200 и пустой request body</br>
	Провал регистрации: описанная выше ошибка</br></br>
	
	<b>Делегированная авторизация через api 42</b></br>
	Этот эндпоинт не для фронта. Чтобы авторизароваться, нужно отправить GET запрос по ссылочке, которую я дам отдельно</br>
	Эта ссылочка будет редиректить api 42 на данный эндпоинт, который будет отвечать тебе токеном и данными пользователя</br>
	(в случае успеха) либо ошибкой в случае провала или отказа пользователя предоставлять права</br>
	Успех и провал точно такие же как и при базовой авторизации</br></br>

	<b>Эндпоинт проверки, авторизации пользователя</b></br>
	Предназначен только для внутренних запросов от других сервисов. Требуется знать пароль от сервера (безопасность)</br>
	В теле запроса нужно в json завернуть поля access_token для моего авторизационного токена и server_passwd для пароля сервера</br>
	Три варианта ответа сервера. 200 - токен валиден, пользователь авторизован</br>
	401 - проверка подписи провалена, пользователь не авторизован</br>
	Все остальное - ошибки, которые следует обрабатывать отдельно (пароль сервера не тот, и т д)</br></br>

	</body></html>`

	successResponse(w, []byte(response))
	logger.Log(r, "programmer wants to know endpoints")
}
